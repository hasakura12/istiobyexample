<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><link href="https://fonts.googleapis.com/css?family=Chivo|Fira+Code|Noto+Sans&display=swap" rel=stylesheet><link rel="shortcut icon" href=../images/spider-web.png><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light only"><meta name=supported-color-schemes content="light only"><title>Egressトラフィック監視&nbsp;&ndash;&nbsp;Istio By Example</title><link rel=stylesheet href=../css/core.min.c21544ff2a034abc45c53862bc2905af5c563887f811bc35b5faa39fb144a3339505a8f8c3e4250a49571f9cac22a64e.css integrity=sha384-whVE/yoDSrxFxThivCkFr1xWOIf4Ebw1tfqjn7FEozOVBaj4w+QlCklXH5ysIqZO><meta property="og:title" content="Egressトラフィック監視"><meta property="og:description" content="サービスメッシュについて考える1つの方法は、ドメイン制御です。 Istioサイドカーインジェクションが有効になっているKubernetesのN"><meta property="og:type" content="article"><meta property="og:url" content="/monitoring-egress-traffic/"><meta property="og:image" content="/images/istio-framed.jpg"><meta property="article:published_time" content="2019-12-31T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-06T21:59:17+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/images/istio-framed.jpg"><meta name=twitter:title content="Egressトラフィック監視"><meta name=twitter:description content="サービスメッシュについて考える1つの方法は、ドメイン制御です。 Istioサイドカーインジェクションが有効になっているKubernetesのN"></head><body><div class="base-body max-width"><section id=header class="header max-body-width"><p><a class=home href=../><img class=site-logo src=../images/istio-logo.png alt>
<span class=site-name>Istio By Example</span></a></p></section><div id=content class="flex-body max-body-width"><section class=article-header><h1 class=article-title>Egressトラフィック監視</h1></section><div class=flex-body><article class=markdown-body><p>サービスメッシュについて考える1つの方法は、ドメイン制御です。 Istio<a href=https://istio.io/docs/ops/deployment/architecture/#components target=_blank>サイドカーインジェクション</a>が有効になっているKubernetesのNamespaceで、Pod間のすべてのトラフィックを<a href=https://istio.io/docs/tasks/observability/ target=_blank>監視</a>し、セキュリティポリシーを<a href=https://istio.io/docs/tasks/security/authorization/authz-http/ target=_blank>適用</a>できます。</p><p>しかし、メッシュの外側にあるアップストリームサービスはどうでしょうか。どのサービスが外部APIを呼び出すかを実行時にどうやって決定するのでしょうか？サービスが書き込んでいるデータベースインスタンスをどのようにして知るのでしょうか？または、メッシュ内のサービスが独自の地理的領域内のトラフィックのみを送信していることをどのように確認するのでしょうか？こうしたことは、<a href=https://istio.io/blog/2019/monitoring-external-service-traffic/ target=_blank>IstioのEgress監視</a> が解決します。</p><p><em>Egress</em>は<em>出口</em>を意味します。この場合、Egressトラフィックとは、Istioメッシュから出る必要があるリクエストを意味します。 デフォルトですべてのEgressトラフィックを<a href=https://archive.istio.io/v1.0/docs/tasks/traffic-management/egress/ target=_blank>Istioがブロックした</a>時期がありました。サービスがアクセスする必要があるすべての外部ホストをホワイトリストに登録するには、<a href=https://istio.io/docs/tasks/traffic-management/egress/egress-control/#access-an-external-http-service target=_blank><code>ServiceEntry</code></a>を手動で作成する必要がありました。ServiceEntryは、Istioのサービスレジストリに外部ホストを追加します。これはIstio 1.3で変更され、<code>REGISTRY_ONLY</code> Egressポリシーがデフォルトで <a href=https://istio.io/docs/tasks/traffic-management/egress/egress-control/#envoy-passthrough-to-external-services target=_blank><code>ALLOW_ANY</code></a> になりました。このため、現在メッシュ内サービスは <code>ServiceEntry</code> を必要とせずに、外部サービスに自由にアクセスできます。</p><p>メッシュにどのIstioEgressオプションを選択しても、IstioはすべてのEgressトラフィックを監視できます。また、<a href=https://istio.io/docs/tasks/traffic-management/egress/egress-gateway/#use-case target=_blank>専用のEgressゲートウェイ</a>プロキシを必要とせずに、ワークロードのサイドカープロキシを通してこのEgressトラフィックを監視できます。それがどのように機能するか見てみましょう。</p><p><a target=_blank rel="noopener noreferrer" href=../images/ptbh-diagram.png><img class=img src=../images/ptbh-diagram.png alt></a></p><p>この例では、ユーザーがレシピを共有できるWebサイトを構築しました。コストを最適化するために、ウェブフロントエンドはサーバーレス機能としてKubernetesの外で実行されます。ユーザーがレシピを追加すると、フロントエンドはKubernetesクラスター内のIDジェネレーターサービス（<code>idgen</code>）を呼び出して、そのレシピのIDを作成します。<code>idgen</code> はデフォルトのIstio IngressGatewayを介して公開され、<code>httpbin</code> と呼ばれる外部APIから<a href=http://httpbin.org/uuid target=_blank>ランダムなID</a>を取得します。</p><h2 id=オプション1---passthrough>オプション1 - Passthrough</h2><p>まず、Egressのデフォルト <code>ALLOW_ANY</code> オプションを指定したIstioインストールを使用してみましょう。これは、追加の構成なしで、<code>idgen</code> の <code>httpbin</code> への要求が許可されることを意味します。 <code>ALLOW_ANY</code> が有効になっている場合、Istioは、<code>idgen</code> のサイドカープロキシによって適用される <code>PassthroughCluster</code> と呼ばれるEnvoyクラスターを使用して、Egressトラフィックを監視します。</p><p>Envoy<a href=https://jvns.ca/blog/2018/10/27/envoy-basics/ target=_blank>クラスター</a>は、エンドポイントのバックエンド（または「アップストリーム」）セットであり、外部サービスを表します。 IstioサイドカーEnvoyプロキシは、アプリケーションコンテナーからのインターセプトされたリクエストにフィルターを適用します。これらのフィルターに基づいて、Envoyは特定のルートにトラフィックを送信します。ルートは、トラフィックを送信するクラスターを指定します。</p><p>Istio <code>Passthrough</code> クラスターは、バックエンドが<a href=https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/service_discovery#original-destination target=_blank>元のリクエストの宛先</a>になるように設定されています。したがって、Egressトラフィックで <code>ALLOW_ANY</code> が有効になっている場合、Envoyは単に <code>idgen</code> のリクエストを <code>httpbin</code> に「パススルー」します。</p><p>この構成では、IngressGatewayを介してレシピIDリクエストを送信すると、<code>idgen</code> は <code>httpbin</code> を正常に呼び出すことができます。このトラフィックは、Kialiサービスグラフで <code>PassthroughCluster</code> トラフィックとして表示されます。<code>httpbin</code> が独自のサービスレベルのテレメトリを取得するには、<code>ServiceEntry</code> を追加する必要があります。（後ほど行います。）</p><p><a target=_blank rel="noopener noreferrer" href=../images/ptbh-kiali-passthrough.png><img class=img src=../images/ptbh-kiali-passthrough.png alt></a></p><p>しかし、Prometheusをドリルダウンして、<code>istio_total_requests</code> メトリクスを見つけると、<code>PassthroughCluster</code> トラフィックが <code>httpbin.org</code> と呼ばれる <code>destinationservice</code> に向かっていることがわかります。</p><p><a target=_blank rel="noopener noreferrer" href=../images/ptbh-prom-passthrough.png><img class=img src=../images/ptbh-prom-passthrough.png alt></a></p><h2 id=オプション2---registry_onlyno-serviceentry>オプション2 - REGISTRY_ONLY、no ServiceEntry</h2><p>ここで、httpbin の <code>ServiceEntry</code> を追加する前に、すべてのEgressトラフィックをロックしたいとします。これを行うには、送信トラフィックの<a href=https://istio.io/docs/reference/config/installation-options/ target=_blank>グローバルインストールオプション</a>を <code>REGISTRY_ONLY</code> に更新し、Istioインストールマニフェストを再適用します。</p><p>今度は、<a href=https://istio.io/blog/2019/monitoring-external-service-traffic/#what-are-blackhole-and-passthrough-clusters target=_blank><code>BlackHole</code></a>という新しいクラスターが登場します。ブラックホールクラスターは、IPエンドポイントのないバックエンドです。 <code>BlackHoleCluster</code> にルーティングされたリクエストはEnvoyによってドロップされ、<code>502: Bad Gateway</code> エラーが返されます。実際には、Egressリクエストをドロップするサイドカープロキシのコレクションは、<code>REGISTRY_ONLY</code> ポリシーが適用される方法です。</p><p><code>REGISTRY_ONLY</code> オプションを有効にしてIstioを再インストールし、<code>idgen</code> Podを再デプロイすると、<code>BlackHoleCluster</code> がリクエストをインターセプトしていることがわかります。赤いグラフの端は、HTTPリクエストが完了しないことを意味します-トラフィックは目的の <code>httpbin.org</code> エンドポイントに到達できません。</p><p><a target=_blank rel="noopener noreferrer" href=../images/ptbh-kiali-blackhole.png><img class=img src=../images/ptbh-kiali-blackhole.png alt></a></p><p>Prometheusでは、<code>istio_total_requests</code> メトリクスが <code>BlackHoleCluster</code> トラフィックを考慮していることがわかります。実際には、このメトリクスにアラートを設定して、クラスター内のサービスによって試みられた<a href=https://en.wikipedia.org/wiki/Data_exfiltration target=_blank>data exfiltration</a>を検出できます。このモードでは、Prometheusはブロックされたリクエストの送信元と（試行された）宛先の両方のワークロードを通知できます。</p><p><a target=_blank rel="noopener noreferrer" href=../images/ptbh-prom-blackhole.png><img class=img src=../images/ptbh-prom-blackhole.png alt></a></p><h2 id=option-3---registry_only-with-serviceentry>Option 3 - <code>REGISTRY_ONLY</code> with ServiceEntry</h2><p>ここで、<code>idgen</code> が外部APIを呼び出すための承認を得たとしましょう。 Isioレジストリに <code>httpbin</code> を追加する <code>ServiceEntry</code> の作成を承認しました。:</p><div class=highlight><pre class=chroma><code class=language-YAML data-lang=YAML><span class=k>apiVersion</span><span class=p>:</span><span class=w> </span>networking.istio.io/v1alpha3<span class=w>
</span><span class=w></span><span class=k>kind</span><span class=p>:</span><span class=w> </span>ServiceEntry<span class=w>
</span><span class=w></span><span class=k>metadata</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=w>  </span><span class=k>name</span><span class=p>:</span><span class=w> </span>httpbin-ext<span class=w>
</span><span class=w></span><span class=k>spec</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=w>  </span><span class=k>hosts</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=w>  </span>- httpbin.org<span class=w>
</span><span class=w>  </span><span class=k>ports</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=w>  </span>- <span class=k>number</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span><span class=w>    </span><span class=k>name</span><span class=p>:</span><span class=w> </span>http<span class=w>
</span><span class=w>    </span><span class=k>protocol</span><span class=p>:</span><span class=w> </span>HTTP<span class=w>
</span><span class=w>  </span><span class=k>resolution</span><span class=p>:</span><span class=w> </span>DNS<span class=w>
</span><span class=w>  </span><span class=k>location</span><span class=p>:</span><span class=w> </span>MESH_EXTERNAL<span class=w>
</span></code></pre></div><p>これで、リクエストがメッシュを正常に脱出し、<code>BlackHoleCluster</code> によってドロップされていないことがわかります。:</p><p><a target=_blank rel="noopener noreferrer" href=../images/ptbh-kiali-serviceentry.png><img class=img src=../images/ptbh-kiali-serviceentry.png alt></a></p><p>また、ServiceEntryを使用すると、Istioは、Kubernetesクラスターの外にあり、制御ドメインの一部ではありませんが、httpbinを別のメッシュサービスとして扱います。これで、<code>httpbin</code> 専用のテレメトリを取得できるようになりました。別の外部サービスを追加すると、サービスグラフに独自の別個のノードとして表示されます。</p><p>Egressトラフィック監視について詳しく学ぶ：</p><ul><li><a href=https://istio.io/blog/2019/monitoring-external-service-traffic/ target=_blank>Istioブログ：Neeraj Poddarによる、ブロックされたパススルー外部サービストラフィックの監視</a></li><li><a href=https://istio.io/docs/reference/config/policy-and-telemetry/metrics/ target=_blank>Istio Docs：デフォルトの指標</a></li><li><a href=https://jvns.ca/blog/2018/10/27/envoy-basics/ target=_blank>Envoy Basics、by Julia Evans</a></li></ul></article></div><section id=footer class=footer><p>Made with ❤️ by <a href=https://twitter.com/askmeegs>Megan O'Keefe</a> | <a href=https://github.com/askmeegs/istiobyexample>Source</a> | <a href=https://github.com/cntrump/hugo-notepadium>Theme</a></p></section></div></div></body></html>